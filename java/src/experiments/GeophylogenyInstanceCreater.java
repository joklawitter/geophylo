package experiments;

import java.util.ArrayList;
import java.util.Random;

import model.Tree;
import model.Vertex;
import model.Geophylogeny;
import model.Site;

/**
 * This class provides generators for different instances of geophylogenies,
 * namely, uniform (sites uniform random on map), clustered (sites around random
 * cluster centres), and coastline (sites like "along a coastline"). The
 * phylogenetic tree on top of the generated sites is generated by randomly
 * merging leafs and subtrees based with higher probability for closer pairs of
 * corresponding sites/medians of corresponding sites in clade.
 *
 * @author Jonathan Klawitter
 */
public class GeophylogenyInstanceCreater {

	/** Padding between border of map and sites. */
	public static int PADDING = 15;

	/** Minimum distance between any two sites. */
	public static double MIN_DISTANCE = 5;

	/** Minimum size for a cluster in cluster instances. */
	public static int MIN_CLUSTER_SIZE = 3;

	/** Factor used to compute fraction that clusters spread out over on map. */
	public static double CLUSTER_FACTOR = 1.5;

	/** Exponent used for distance-based clustering in tree generation. */
	public static double EXPONENT = 1;

	/**
	 * Generates a new geophylogeny with given number of sites/taxa, where the
	 * sites are placed uniformly at random on the map.
	 * 
	 * @param mapWidth
	 *            width of the map of the new geophylogeny
	 * @param mapHeight
	 *            height of the map of the new geophylogeny
	 * @param numTaxa
	 *            number of taxa and sites of the new geophylogeny
	 * @param instanceName
	 *            name for the new geophylogeny
	 * @param seed
	 *            seed for the random number generator
	 * @return a new geophylogeny with uniformly randomly placed sites
	 */
	public static Geophylogeny generateUniformInstance(int mapWidth, int mapHeight, int numTaxa,
			String instanceName, long seed) {
		Random random = new Random(seed);
		Site[] sites = generateUniformSites(mapWidth, mapHeight, numTaxa, PADDING, random);

		for (int i = 0; i < numTaxa; i++) {
			sites[i].setLeaf(new Vertex(i + 1));
		}

		Vertex root = constructTreeOnSites(sites, numTaxa + 1, random);
		Tree tree = new Tree(root, numTaxa);

		return new Geophylogeny(tree, sites, mapWidth, mapHeight, instanceName);
	}

	/**
	 * Generates a new geophylogeny with given number of sites/taxa, where the
	 * sites are clustered and placed randomly around randomly placed cluster
	 * centres.
	 * 
	 * @param mapWidth
	 *            width of the map of the new geophylogeny
	 * @param mapHeight
	 *            height of the map of the new geophylogeny
	 * @param numTaxa
	 *            number of taxa and sites of the new geophylogeny
	 * @param numClusters
	 *            number of clusters of the new geophylogeny
	 * @param instanceName
	 *            name for the new geophylogeny
	 * @param seed
	 *            seed for the random number generator
	 * @return a new geophylogeny with sites randomly placed in clusters
	 */
	public static Geophylogeny generateClusteredInstance(int mapWidth, int mapHeight, int numTaxa,
			int numClusters, String instanceName, long seed) {
		Random random = new Random(seed);

		// a) initialize cluster sizes
		int[] clusterSizes = new int[numClusters];
		for (int i = 0; i < clusterSizes.length; i++) {
			clusterSizes[i] = MIN_CLUSTER_SIZE;
		}
		int clusterSizesSum = MIN_CLUSTER_SIZE * numClusters;
		if (clusterSizesSum > numTaxa) {
			throw new AssertionError(
					"Num taxa is smaller than num clusters times min cluster size");
		}

		while (clusterSizesSum < numTaxa) {
			clusterSizes[random.nextInt(clusterSizes.length)]++;
			clusterSizesSum++;
		}

		// b) initialize cluster medians and cluster sites
		Site[] clusterMedians = generateUniformSites(mapWidth, mapHeight, numClusters, 2 * PADDING,
				random);

		// c) create subtrees for each cluster
		Site[] allSites = new Site[numTaxa];
		int allSitesIndex = 0;
		Site[][] clusterSites = new Site[numClusters][];
		Vertex[][] clusters = new Vertex[numClusters][];
		int nextVertexId = 1;
		// i) first create sites
		for (int i = 0; i < clusterSites.length; i++) {
			double fraction = (CLUSTER_FACTOR * clusterSizes[i]) / numTaxa;
			clusterSites[i] = generateClusterSites(mapWidth, mapHeight, clusterSizes[i],
					clusterMedians[i], fraction, random);
			clusters[i] = new Vertex[clusterSizes[i]];

			// ii) and give each a leaf
			for (int j = 0; j < clusterSites[i].length; j++) {
				Vertex leaf = new Vertex(nextVertexId++);
				clusterSites[i][j].setLeaf(leaf);
				clusters[i][j] = leaf;
				allSites[allSitesIndex++] = clusterSites[i][j];
			}
		}

		// iii) then build tree on top
		for (int i = 0; i < clusterSites.length; i++) {
			Vertex clusterRoot = constructTreeOnSites(clusterSites[i], nextVertexId, random);
			clusterMedians[i].setLeaf(clusterRoot);
			nextVertexId = clusterRoot.getID() + 1;
		}

		// merge clusters
		Vertex root = constructTreeOnSites(clusterMedians, nextVertexId, random);
		Tree tree = new Tree(root, numTaxa);

		Geophylogeny geophylogeny = new Geophylogeny(tree, allSites, mapWidth, mapHeight,
				instanceName);
		geophylogeny.setClustersByTable(clusters);

		return geophylogeny;
	}

	/**
	 * Generates a new geophylogeny with given number of sites/taxa, where the
	 * sites are placed as if along a coastline with the following method.
	 * 
	 * The first site is placed in the centre of the map, then one half is
	 * placed equidistantly to the left one at a time and the other half is
	 * placed equidistantly to the right one at a time. The x-coordinate is then
	 * randomly shifted to the left/right. The y-coordinate of every placed site
	 * varies randomly from the y-coordinate of the previous site.
	 * 
	 * @param mapWidth
	 *            width of the map of the new geophylogeny
	 * @param mapHeight
	 *            height of the map of the new geophylogeny
	 * @param numTaxa
	 *            number of taxa and sites of the new geophylogeny
	 * @param instanceName
	 *            name for the new geophylogeny
	 * @param seed
	 *            seed for the random number generator
	 * @return a new geophylogeny with sites placed randomly roughly on a line
	 *         like a coastline
	 */
	public static Geophylogeny generateCoastlineInstance(int mapWidth, int mapHeight, int numTaxa,
			String instanceName, long seed) {
		// System.out.println(
		// "> generate coastline geophylogeny instance (" + instanceName + ", "
		// + seed + ")");
		Random random = new Random(seed);

		double effectiveWidth = mapWidth - 2 * PADDING;

		// a) create x-coordinates:
		// evenly spaced + random shift
		double[] xs = new double[numTaxa];
		double xStep = effectiveWidth / (numTaxa + 1);
		double xOffset = PADDING + xStep / 2;
		for (int i = 0; i < xs.length; i++) {
			xs[i] = xOffset + i * xStep;
			double xShift = random.nextDouble() * xStep;
			xs[i] += random.nextBoolean() ? xShift : -xShift;
			xs[i] = Math.max(xs[i], PADDING);
			xs[i] = Math.min(xs[i], (mapWidth - PADDING));
		}

		// b) create y-coordinates:
		// neighboring y-coordinate + random shift
		// starting with middle one in center
		double[] ys = new double[numTaxa];
		double yStep = 1.5 * xStep;
		int startIndex = numTaxa / 2;
		ys[startIndex] = mapHeight / 2;
		for (int i = startIndex - 1; i >= 0; i--) {
			double yShift = random.nextDouble() * yStep;
			ys[i] = ys[i + 1] + (random.nextBoolean() ? yShift : -yShift);
			if (ys[i] < PADDING) {
				ys[i] = PADDING + random.nextDouble() * yStep;
			}
			if (ys[i] > (mapHeight - PADDING)) {
				ys[i] = mapHeight - random.nextDouble() * yStep;
			}
		}
		for (int i = startIndex + 1; i < numTaxa; i++) {
			double yShift = random.nextDouble() * yStep;
			ys[i] = ys[i - 1] + (random.nextBoolean() ? yShift : -yShift);
			if (ys[i] < PADDING) {
				ys[i] = PADDING + random.nextDouble() * yStep;
			}
			if (ys[i] > (mapHeight - PADDING)) {
				ys[i] = mapHeight - random.nextDouble() * yStep;
			}
		}

		// c) create sites
		Site[] sites = new Site[numTaxa];
		for (int i = 0; i < ys.length; i++) {
			sites[i] = new Site(xs[i], ys[i], new Vertex(i + 1));
		}

		Vertex root = constructTreeOnSites(sites, numTaxa + 1, random);
		Tree tree = new Tree(root, numTaxa);

		return new Geophylogeny(tree, sites, mapWidth, mapHeight, instanceName);
	}

	private static Site[] generateUniformSites(int mapWidth, int mapHeight, int numTaxa,
			double padding, Random random) {
		double effectiveWidth = mapWidth - 2 * padding;
		double effectiveHeight = mapHeight - 2 * padding;

		double xZero = padding;
		double yZero = padding;

		Site[] sites = new Site[numTaxa];
		for (int i = 0; i < sites.length; i++) {
			Site currentSite = null;

			boolean otherSiteTooClose;
			do {
				otherSiteTooClose = false;
				double x = xZero + random.nextDouble() * effectiveWidth;
				double y = yZero + random.nextDouble() * effectiveHeight;
				currentSite = new Site(x, y);

				for (int j = 0; j < i; j++) {
					Site prevSite = sites[j];
					if (currentSite.distanceTo(prevSite) < MIN_DISTANCE) {
						// a prev site is too close to current one, retry
						otherSiteTooClose = true;
						break;
					}
				}
			} while (otherSiteTooClose);

			// all other sites are far enough away from current one
			sites[i] = currentSite;
		}

		return sites;
	}

	private static Site[] generateClusterSites(int mapWidth, int mapHeight, int numTaxa,
			Site referenceSite, double fraction, Random random) {

		double refenceX = referenceSite.getX();
		double refenceY = referenceSite.getY();
		double maxDistance = Math.min(mapWidth - 2 * PADDING, mapHeight - 2 * PADDING) * fraction;
		// System.out.println(fraction);
		// System.out.println(maxDistance);

		Site[] sites = new Site[numTaxa];
		for (int i = 0; i < sites.length; i++) {
			Site currentSite = null;

			boolean otherSiteTooClose;
			do {
				otherSiteTooClose = false;
				double x = random.nextDouble() * maxDistance;
				x = random.nextBoolean() ? x : -x;
				x = refenceX + x;
				double y = random.nextDouble() * maxDistance;
				y = random.nextBoolean() ? y : -y;
				y = refenceY + y;
				if ((x < PADDING) || (x > (mapWidth - PADDING)) || (y < PADDING)
						|| (y > (mapHeight - PADDING))) {
					// coordinates out of range, retry
					otherSiteTooClose = true;

				} else {
					currentSite = new Site(x, y);

					for (int j = 0; j < i; j++) {
						Site prevSite = sites[j];
						if (currentSite.distanceTo(prevSite) < MIN_DISTANCE) {
							// a prev site is too close to current one, retry
							otherSiteTooClose = true;
							break;
						}
					}
				}
			} while (otherSiteTooClose);

			// all other sites (in current cluster) are far enough away
			sites[i] = currentSite;
		}

		return sites;
	}

	private static Vertex constructTreeOnSites(Site[] sites, int nextVertexId, Random random) {
		// The tree is constructed by randomly merging corresponding "real"
		// sites of leaves or a "virtual" site that lies at the median of all
		// the sites that correspond to the clade of a subtree.
		// We thus manage all sites (real and virtual) that are up for being
		// merged, which initially are all real sites.
		ArrayList<Site> unmergedSites = new ArrayList<Site>(sites.length);
		for (Site site : sites) {
			unmergedSites.add(site);
		}

		while (unmergedSites.size() > 1) {
			// a) start with a random site
			Site currentSite = unmergedSites.remove(random.nextInt(unmergedSites.size()));
			Site mergeSite = null;

			// b) to compute probability of other sites being picked:
			// i) compute the inverse distance = (1 / Eucledian distance) to all
			// other sites
			double[] inverseDistances = new double[unmergedSites.size()];
			for (int i = 0; i < inverseDistances.length; i++) {
				Site otherSite = unmergedSites.get(i);
				double distance = currentSite.distanceTo(otherSite);
				distance = Math.pow(distance, EXPONENT);
				inverseDistances[i] = 1 / distance;
			}

			// ii) compute normalization dividend
			double normalizationDividend = 0;
			for (int i = 0; i < inverseDistances.length; i++) {
				normalizationDividend += inverseDistances[i];
			}

			// iii) set probability
			double[] mergeProbability = new double[unmergedSites.size()];
			for (int i = 0; i < inverseDistances.length; i++) {
				mergeProbability[i] = inverseDistances[i] / normalizationDividend;
			}

			// c) pick other site to merge with
			double randomPick = random.nextDouble();
			double sumMergProbs = 0;
			for (int i = 0; i < mergeProbability.length; i++) {
				sumMergProbs += mergeProbability[i];

				if (sumMergProbs >= randomPick) {
					mergeSite = unmergedSites.remove(i);
					break;
				}
			}

			// d) merge the two picked sites
			Vertex parent = new Vertex(nextVertexId++, currentSite.getLeaf(), mergeSite.getLeaf());
			int currentSiteSize = currentSite.getLeaf().getCladeSize();
			int mergeSiteSize = mergeSite.getLeaf().getCladeSize();
			double parentX = (currentSite.getX() * currentSiteSize + mergeSite.getX() * mergeSiteSize)
					/ (currentSiteSize + mergeSiteSize);
			double parentY = (currentSite.getY() * currentSiteSize
					+ mergeSite.getY() * mergeSiteSize) / (currentSiteSize + mergeSiteSize);
			Site parentSite = new Site(parentX, parentY, parent);
			unmergedSites.add(parentSite);
		}

		return unmergedSites.get(0).getLeaf();
	}

}
